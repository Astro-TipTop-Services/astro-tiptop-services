---
id: useful_scripts
title: Tutorials Useful & Scripts
sidebar_label: Tutorials & Useful Scripts
wip: true
---

import useBaseUrl from '@docusaurus/useBaseUrl';
import PasswordGuard from '@site/src/components/PasswordGuard';

<div style={{ textAlign: "justify" }}>
This section provides a collection of useful scripts and detailed tutorials designed to help you
run, extend, and better understand <b>TipTop</b> simulations for your own applications.
</div>

## üìù Tutorials

<PasswordGuard>

### üîµ Understanding Additional Error Terms in TipTop (Jitter, Extra Error and Static aberrations)

<div style={{ textAlign: "justify" }}> 
This tutorial introduces the optional parameters that can be activated in <b>TipTop</b>
to enrich simulated PSFs with additional, user-defined error contributions.  
These parameters allow you to represent effects that are not otherwise considered by **TipTop**, such as 
non common path aberrations (NCPA), manufacturing tolerances, phasing errors in pupil segmented systems, or residual vibrations, ...

These configurable parameters can help you to produce more realistic PSFs, test ‚Äúwhat-if‚Äù error budgets, or reproduce measured PSFs for specific analyses.

Part of the purpose of this tutorial is therefore to illustrate which regions of the PSF 
(core width, halo level, etc.) are most sensitive to each additional error term.  
However, several effects can overlap, and the impact of individual parameters is sometimes 
difficult to distinguish by eye. As a result, manual tuning often requires iterating and 
revisiting parameters more than once. Because some error terms may compensate or mask each other, caution is recommended. <br/> 
Before introducing new aberrations, users should refer to the page 
<i>‚Äú[What is included in TipTop?](/docs/general/error_breakdown)‚Äù</i> to avoid adding errors that are already taken into account.

<p><b>Note on wavelength:</b> the sensitivity of PSF features to these parameters 
depends on the simulation wavelength. Users should perform comparisons at the wavelength(s) 
most relevant for their science case, as different wavelengths emphasise different spatial 
frequency ranges of the PSF.</p>

</div>

---

### Overview of the main parameters

| Parameter | Required? | Type | Description |
| :--------------- |:---------------|:---------------:|:---------------|
| `jitter_FWHM` | No | `float` | _Default:_ `None`, Additional kernel to be convolved with PSF, it could be a scalar (FWHM in **mas**) for a round kernel or a list of three values `[FWHM_mas_max, FWHM_mas_min, angle_rad]`.|
| `extraErrorNm ` | No | `float` | _Default:_ `0`, **nm RMS** of the additional wavefront error to be added (an error that is not otherwise considered).|
| `extraErrorExp` | No | `float` | _Default:_ `-2`, Exponent of the power of spatial frequencies used to generate the PSD associated with `extraErrorNm`. |
| `extraErrorMin` | No | `float` | _Default:_ `0`, Minimum spatial frequency <code>[m<sup>‚àí1</sup>]</code> for which PSD associated with `extraErrorNm` is `> 0`. |
| `extraErrorMax` | No | `float` | _Default:_ `0`, Maximum spatial frequency <code>[m<sup>‚àí1</sup>]</code> for which PSD associated with `extraErrorNm` is `> 0`. <br/> _Note_: `0` means maximum frequency is the one present in the spatial frequency array of the PSDs.|
| `PathStaticOn`  | No | `string`| _Default:_ `None`, Path to a map of static aberrations (**nm**) in .fits file. If absent or `‚Äò‚Äô`, not used.|
| `zCoefStaticOn` | No | `list`| _Default:_ `None`, Vector with zernike amplitudes of a static aberration. Coefficients are in **nm RMS**. If absent not used.|

---

### 1. Jitter (`jitter_FWHM`)

<div style={{ textAlign: "justify" }}> 
The parameter `jitter_FWHM` defines a Gaussian kernel (FWHM in _mas_) that is convolved with the final PSF.
It is used to model an additional tip/tilt jitter ( e.g. vibrations, PSF drifts, ...).
</div>

<div style={{
  borderLeft: "4px solid #4ea3f1",
  background: "#e8f4ff",
  padding: "10px 14px",
  margin: "12px 0",
  borderRadius: "4px"
}}>
‚úèÔ∏è **<i>Implementation note:</i>** <br/> This Gaussian convolution is applied at the final stage of 
TipTop‚Äôs pipeline (in [<code>tiptop.baseSimulation.finalConvolution()</code>](https://github.com/astro-tiptop/TIPTOP/blob/d5cceb2d215e81004218b67bca10b6ef87dc8b92/tiptop/baseSimulation.py#L530C9-L530C25)).

</div>

How to define it: 
 - Circular jitter
 ```python
 [telescope]
 jitter_FWHM = 30.0   ; in mas
 ```

 - Elliptical jitter:
 ```python
 [telescope]
 jitter_FWHM = [25.0, 20.0, 30.0]  ; FWHM_X, FWHM_Y [mas], angle [deg]
 ```
    
**Effects of `jitter_FWHM`** : 
<div style={{ textAlign: 'justify' }}> 
<ul> 
<li><b>Broadens the PSF core</b> (direct effect). </li> 
<li><b>Increases the PSF FWHM</b> as the jitter amplitude grows.</li>
<li><b>Reduces the Strehl ratio</b>, since energy leaves the core.</li> 
<li><b>Slightly smooths the halo</b></li> 
</ul>

Because <code>jitter_FWHM</code> corresponds to tip‚Äìtilt‚Äìdominated residuals, it mainly acts on
the lowest spatial frequencies: it widens the core while having minimal effect on the
shape of the outer AO halo.
</div>

<p align="center">
![jitter_FWHMa](/img/jitter_fwhm_0.jpg) 
</p>

<div style={{
  borderLeft: "4px solid #2ed373ff",
  background: "#f1ffe8ff",
  padding: "10px 14px",
  margin: "12px 0",
  borderRadius: "4px",
  textAlign: 'justify'
}}>

**Tuning** 

<div style={{ textAlign: 'justify' }}> 
In practice, this extra parameter is often added first, then its value is refined after introducing <code>extraError*</code> and 
<code>zCoefStaticOn</code>, since these parameters also modify the core‚Äìhalo energy balance 
(although through different mechanisms).

</div>
</div>

###  2. Extra high-order error (`extraErrorNm`, `extraErrorExp`, `extraErrorMin`, `extraErrorMax`)

<div style={{ textAlign: "justify" }}> 

The `extraError*` parameters allow you to introduce an additional, user-defined wavefront error 
described by a simple spatial-frequency power law. <br/>
This term is useful to model high-order aberrations not otherwise represented in **TipTop**, such as 
residual manufacturing erros, residual telescope contributions, or any unmodelled generic high-order 
static term.  
{/* e.g. PFRO residuals, high-order telescope WFE (M1 & M2), or WFS spot-truncation effects */}

</div>

<div style={{
  borderLeft: "4px solid #4ea3f1",
  background: "#e8f4ff",
  padding: "10px 14px",
  margin: "12px 0",
  borderRadius: "4px",
  textAlign: 'justify'
}}>
‚úèÔ∏è **<i>Implementation note:</i>** <br/>
TipTop computes an **additional PSD** from these
parameters inside [<code>p3.aoSystem.fourierModel.extraErrorPSD()</code>](https://github.com/astro-tiptop/P3/blob/c074643ffa6ddb4b5b2424749a5f10e7d413b6f7/p3/aoSystem/fourierModel.py#L1328), and this PSD is then
<b>added to the AO PSD</b> in [<code>p3.aoSystem.fourierModel.powerSpectrumDensity()</code>](https://github.com/astro-tiptop/P3/blob/c074643ffa6ddb4b5b2424749a5f10e7d413b6f7/p3/aoSystem/fourierModel.py#L650)
(after aliasing, noise, temporal and other contributions).<br/>
This provides a straightforward way to inject a generic static high-order
aberration PSD into the error budget.

</div>

**Meaning of the parameters**

<div style={{ textAlign: "justify" }}> 
<ul> <li><code>extraErrorNm</code> ‚Äì total RMS amplitude (in _nm_) of the additional error</li> 
<li><code>extraErrorExp</code> ‚Äì exponent of the power-law spectrum (default ‚Äì2)</li> 
<li><code>extraErrorMin</code> / <code>extraErrorMax</code> ‚Äì optional lower/upper spatial-frequency limits (in _m<sup>‚àí1</sup>_).</li> </ul> 
</div>


**Effects of the `extraError*` parameters**

<div style={{ textAlign: "justify" }}>

 - <b>Strehl ratio reduction</b>  
  Increasing <code>extraErrorNm</code> increases the total WFE and transfers energy 
  from the PSF core into the halo.
 - <b>Encircled-energy modification</b>  
  Higher <code>extraErrorNm</code> values decrease EE at small radii and increase it at larger radii.
- <b>Halo-shape variation</b>  
  The power-law exponent <code>extraErrorExp</code> controls how energy is distributed across spatial frequencies:  
  <ul>
    <li>steeper (more negative) slopes ‚Üí more low-frequency power ‚Üí broader halo</li>
    <li>shallower slopes ‚Üí more high-frequency power ‚Üí sharper halo edge</li>
  </ul>
</div>

<p align="center">
![ExtraErrorNm](/img/extra_errora.jpg) 
</p>

<div style={{ textAlign: "justify" }}>
The exponent <code>extraErrorExp</code> determines how quickly the PSD decreases with frequency.  
Both the Strehl ratio and the radial profile are sensitive to it: modifying the exponent 
changes how energy is redistributed between intermediate and high spatial frequencies, 
which directly affects the core‚Äìto‚Äìhalo balance.

<code>extraErrorMin</code> and <code>extraErrorMax</code> further allow you to restrict 
the spatial-frequency range over which the additional error is applied.
</div>

<p align="center">
![ExtraErrorM](/img/extra_errorb.jpg) 
</p>

<div style={{
  borderLeft: "4px solid #2ed373ff",
  background: "#f1ffe8ff",
  padding: "10px 14px",
  margin: "12px 0",
  borderRadius: "4px",
  textAlign: 'justify'
}}>
**Tuning** 

<div style={{ textAlign: "justify" }}>
In practice, after adding <code>jitter_FWHM</code>, the 
<code>extraError*</code> parameters are typically used to adjust the level and shape of the 
halo.  

A larger <code>extraErrorNm</code> decreases the Strehl ratio by injecting 
additional high-order wavefront error, thereby raising the halo.  
The exponent <code>extraErrorExp</code> then provides finer control over the 
halo slope by redistributing energy between intermediate and high spatial 
frequencies.

Because the effects of several parameters can partially overlap, the tuning process is 
iterative: modifying <code>extraErrorNm</code> often requires 
revisiting <code>extraErrorExp</code>, and these adjustments must remain 
consistent with any static aberrations introduced through 
<code>zCoefStaticOn</code> or <code>PathStaticOn</code>.


In the "MUSE PSF-fitting" example shown below (for a science wavelength of 500_nm_), 
the effect of <code>extraErrorNm</code> and <code>extraErrorExp</code> 
on the radial and directional profiles can be inspected to determine which combination best reproduces the observed halo amplitude and slope. 
The plots illustrate how varying these parameters affect the PSF shape during manual tuning. 
For simplicity, only the X-cut of the PSF is shown here for a single star ‚Äî 
the objective is purely to visualize the qualitative impact of these parameters.<br/>
<i>Note:</i> the example results correspond to simulations using <code>zCoefStaticOn = [0, 0, 100]</code> (focus term added).

<p align="center"> ![ExtraErrorNm_Exp](/img/extraErrorNm_Exp.jpg)  </p>

</div>
</div>

### 3. Static aberrations (<code>PathStaticOn</code>, <code>zCoefStaticOn</code>)

<div style={{ textAlign: "justify" }}>

Static aberrations correspond to wavefront errors that are fixed in time and do not evolve
during the simulation.  
In <b>TipTop</b>, to introduce such static terms you can define:
<ul>
<li>a user-provided OPD map (<code>PathStaticOn</code>)</li>
<li>a set of Zernike coefficients (<code>zCoefStaticOn</code>)</li>
</ul>

</div>

<div style={{
  borderLeft: "4px solid #4ea3f1",
  background: "#e8f4ff",
  padding: "10px 14px",
  margin: "12px 0",
  borderRadius: "4px",
  textAlign: 'justify'
}}>
‚úèÔ∏è <i><b>Implementation note:</b></i>  <br/>
Both contributions are combined into an on-axis OPD map (in nm) inside the
<code>telescope</code> class (attribute [<code>tel.opdMap_on</code>](https://github.com/astro-tiptop/P3/blob/c074643ffa6ddb4b5b2424749a5f10e7d413b6f7/p3/aoSystem/telescope.py#L122)).
This OPD map is then applied in the pupil plane when computing the final PSFs, on top of the AO residual
wavefront error.
</div>

---

**3.1 Using an OPD map (PathStaticOn)**

<div style={{ textAlign: "justify" }}>
<code>PathStaticOn</code> allows you to load a static optical path difference map (in _nm_)
from a `FITS` file.  
It adds a static aberration (it can be used to add any kind of static aberrations).

This is the recommended approach when you have a measured or simulated aberration map.<br/>
The OPD map is rescaled/rotated to match the telescope pupil resolution and geometry and is then
used as an additional OPD term during PSF computation.
</div>

One example is the static aberration given by ELT M1 ([available here](https://github.com/astro-tiptop/TIPTOP/blob/main/tiptop/data/ELT_M1_MORFEO_DMs_static_wfe_480px.fits)).

<p align="center">
![PathStaticOn](/img/PathStaticOn.jpg) 
</p>

---

**3.2 Using Zernike coefficienrs (`zCoefStaticOn`)**
<div style={{ textAlign: "justify" }}>
`zCoefStaticOn` provides a compact way to introduce a combination of zernike modes that model a static aberration. 
The values are given in <i>nm RMS</i> and follow the standard <b>Noll index</b> ordering (Z2 = tilt, Z3 = tilt, Z4 = defocus, Z5‚ÄìZ6 = astigmatism, ‚Ä¶).

</div>

<div style={{
  borderLeft: "4px solid #4ea3f1",
  background: "#e8f4ff",
  padding: "10px 14px",
  margin: "12px 0",
  borderRadius: "4px",
  textAlign: 'justify'
}}>
‚úèÔ∏è <i><b>Implementation note:</b></i>  
Inside <code>telescope</code> class, TipTop:
<ul> 
<li>builds the corresponding Zernike basis on the pupil,</li> 
<li>orthonormalizes the modes on the actual pupil support,</li> 
<li>normalizes each mode to 1 nm RMS,</li> 
<li>and finally forms <code>opdMap_on</code> by summing the modes weighted by the coefficients in <code>zCoefStaticOn</code>.</li> 
</ul> 
</div>

Examples:

| Mode | `zCoefStaticOn`  | 
| :--------------- |:---------------|
| Focus | [0, 0, 100] | 
| Astigmastism | [0, 0, 0, 100] |
| Trefoil | [0, 0, 0, 0, 0, 0, 0, 100] |
| Spherical| [0, 0, 0, 0, 0, 0, 0, 0, 0, 100] |

<p align="center">
![Zernike_modes](/img/zernike_poly.png) 
</p>


**Effects of static aberrations**
<div style={{ textAlign: "justify" }}> 
<ul> 
<li><b>Strehl ratio degradation</b> ‚Äî depending on the total RMS and the Zernike content.</li> 
<li><b>PSF shape modification</b> ‚Äî ZErnike modes introduce directional features (e.g. astigmatism, coma), while arbitrary OPD maps can create more complex patterns.</li> 
<li><b>Energy redistribution</b> ‚Äî static aberrations alter both the PSF core and halo, with characteristic signatures depending on the aberration type.</li> 
{/* <li><b>No temporal averaging</b> ‚Äî these aberrations are fixed and present in all simulated PSFs.</li> */}
</ul> 
</div>


**Typical use**
<div style={{ textAlign: "justify" }}> 
Use <code>PathStaticOn</code> when you have a known, structured pupil-plane aberration 
(e.g. calibration-derived NCPA, optics maps, segmented mirror errors). <br/>
Use <code>zCoefStaticOn</code> to explore the impact of specific modes (focus, astigmatism, trefoil, ‚Ä¶)
or to test simple static error scenarios in a controlled way.

</div>

<div style={{
  borderLeft: "4px solid #2ed373ff",
  background: "#f1ffe8ff",
  padding: "10px 14px",
  margin: "12px 0",
  borderRadius: "4px",
  textAlign: 'justify'
}}>
**Tuning**

In our "MUSE tuning example", a set of Zernike coefficients was used together with <code>jitter_FWHM</code> 
and <code>extraError*</code> to reproduce the observed PSF, matching both core width and halo level.

The example below illustrates the impact of adding a simple defocus term via
<code>zCoefStaticOn = [0, 0, 100]</code> on the PSF shape (X-cut only, for clarity).
<p align="center">
![zCoefStaticOn](/img/zCoefStaticOn.jpg) 
</p>
</div> 




{/* ### 4. Recommended Workflow for Tuning Additional Error Terms
 <details>
  <summary><strong> Click here to read more. </strong></summary> 

<div style={{ textAlign: "justify" }}> 
This section provides a practical step-by-step approach for tuning the optional parameters (<code>jitter_FWHM</code>, 
<code>extraError*</code>, <code>PathStaticOn</code>, <code>zCoefStaticOn</code>) when refining a PSF or exploring a specific error budget. 
The key principle is to adjust one contribution at a time. 
</div>

**Step-by-step procedure**

1. **Start from a ‚Äúclean‚Äù AO simulation**

<div style={{ textAlign: "justify" }}> 
Set all additional error terms to zero: 
<ul> 
<li><code>jitter_FWHM = None</code></li> 
<li><code>extraErrorNm = 0</code></li> 
<li><code>PathStaticOn = None</code></li> 
<li><code>zCoefStaticOn = None</code></li> 
</ul> 

Run a simulation and record the basic metrics: FWHM, SR, EE and inspect radial profile. 
</div>

2. **Tune the jitter contribution**

<div style={{ textAlign: "justify" }}> 
Increase <code>jitter_FWHM</code> to adjust the broadening of the PSF core. This step isolates the contribution of tip/tilt-like 
residual motion. 
</div>

3. **Add high-order extra error**

<div style={{ textAlign: "justify" }}> 
Adjust <code>extraErrorNm</code> (and, if needed, <code>extraErrorExp</code>) to modify the halo level and the 
encircled-energy distribution. This step accounts for additional high-order wavefront error not included in the AO model. 
</div>

4. **Add static aberrations if needed**

<div style={{ textAlign: "justify" }}> 
If the PSF exhibits a characteristic static shape (e.g. astigmatism, coma, trefoil), introduce: 
<ul> 
<li>simple Zernike modes via <code>zCoefStaticOn</code>, or</li> 
<li>a more detailed aberration map via <code>PathStaticOn</code> if one is available.</li> 
</ul> 

These terms capture structured, time-independent aberrations. 
</div>

5. **Iterate**

<div style={{ textAlign: "justify" }}> 
Repeat steps 2‚Äì4, modifying <b>only one parameter group at a time</b>, until the overall PSF shape and metrics are 
consistent with the targeted behaviour. Progressive, isolated adjustments make each contribution easier to interpret. 
</div>

6. **Check global consistency**

<div style={{ textAlign: "justify" }}> 
Use the global error budget (e.g. from <code>errorBreakDown()</code>) to ensure that the total WFE and the relative 
contributions (AO residuals, static terms, extra error, jitter) remain physically plausible for the instrument configuration 
being simulated. 
</div>
*/}
{/* </details> */}


{/* <p align="center">
<b>TipTop AO Simulation</b><br/>
‚Üì<br/>
<b>Jitter</b> (<code>jitter_FWHM</code>) ‚Äì broadens the PSF core<br/>
‚Üì<br/>
<b>Extra high-order error</b> (<code>extraError*</code>) ‚Äì modifies halo & EE<br/>
‚Üì<br/>
<b>Static aberrations</b> (<code>PathStaticOn</code>, <code>zCoefStaticOn</code>) ‚Äì adds fixed structure<br/>
‚Üì<br/>
<b>Final PSF</b>
</p> */}








{/* #### 1. Where do these parameters act?
The high-order AO part is handled by p3.aoSystem.fourierModel, which computes the HO residual PSD
(fitting, aliasing, noise, temporal error, cone effect, etc.).
In this step, extraErrorNm and related parameters are injected via
extraErrorPSD() / extraErrorLoPSD(), and static aberrations are applied
through the telescope OPD map (NCPA).

The PSF generation and final convolution are handled by baseSimulation:
the HO PSD is converted to PSFs, combined with the LO error model (if enabled),
and then optionally convolved with a jitter kernel defined by jitter_FWHM. */}


</PasswordGuard>

## üìÑ Useful Scripts 

### üîµ Run <i>N</i> **TipTop** Simulations with Different Parameter Values

<div style={{ textAlign: "justify" }}>
Here, we provide an example script to run <i>N</i> **TipTop** simulations with different values of two parameters:
`ZenithAngle` and `Seeing`. The script can easily be adapted to sweep over a single parameter or more than two.
</div>

**Download the script:**
<a href={`${useBaseUrl('/downloads/TIPTOP_RUN_N_SIM.py')}`} download="TIPTOP_RUN_N_SIM.py"><span style={{ fontSize: '1.5em' }}>üì•</span></a>.

<details>
  <summary><strong> Running <i>N</i> **TipTop** simulations: `TIPTOP_RUN_N_SIM.py` </strong></summary>

  ```python
"""
Created on Thu Jul 10 10:00:34 2025
Run N TIPTOP simulations by sweeping over different parameter values.

@author: astro-tiptop-services
"""

#%% =============================================================================
# Import necessary libraries
from tiptop.tiptop import overallSimulation
import numpy as np
import configparser
from itertools import product
import os

#%% =============================================================================
# === File Paths ===
#üí° Adapt these paths to your environment
inputDir = "../MICADO/"   # Folder containing the .ini parameter file
inTag = "MICADO_SCAO"     # Name of the input parameter file (without extension)
outputDir = "./"          # Folder where the output FITS files will be saved 
tempDir = inputDir        # Temporary folder for modified .ini files
tempName = 'file_temp'    # Name of the temporary file

# Construct the full path to the input and temporary config files
inputFile = os.path.join(inputDir, f"{inTag}.ini")
tempFile = os.path.join(tempDir, f"{tempName}.ini")

# Base name for output files
outTagBase = "MICADO"

#%% =============================================================================
# === Define parameters to sweep ===
# üí° Format: (section_name, key_name, list_of_values : min, max, number of values)
param_sweep = [
    ("atmosphere", "Seeing", np.linspace(0.8, 2.0, 3)),
    ("telescope", "ZenithAngle", np.linspace(0.0, 60.0, 3)),
    # Add more parameters as needed
]

#%% =============================================================================
# === Read base configuration file ===
parser = configparser.ConfigParser()
parser.optionxform = str # Keep the original case of parameter keys
parser.read(inputFile)

#%% =============================================================================
# === Build and run combinations ===

# Extract parameter names and values
param_names = [f"{sec}.{key}" for sec, key, _ in param_sweep]
param_values = [vals for _, _, vals in param_sweep]

# Generate all combinations
for combo in product(*param_values):
    # Update .ini with current parameter values
    for (section, key, _), value in zip(param_sweep, combo):
        parser.set(section, key, str(value))
              
        # Write updated config to temporary .ini file
        with open(tempFile, "w") as configfile:
            parser.write(configfile)
        
        # Build output file tag
        tag_parts = [f"{name.split('.')[-1]}{val:.2f}" for name, val in zip(param_names, combo)]
        tag = f"{outTagBase}_{'_'.join(tag_parts)}"
        
        print(f"üîÑ Running simulation with: {dict(zip(param_names, combo))}")
        
        # Run TipTop simulation
        overallSimulation(
            path2param=tempDir,
            parametersFile=tempName,
            outputDir=outputDir,
            outputFile=tag,
            addSrAndFwhm=True
        )
  ```

</details>

### üîµ Rename Output FITS Files and Keep Backups

<div style={{ textAlign: "justify" }}>
This script renames PSF FITS files (e.g., those generated by the previous script)
to facilitate their use in other routines, while creating backups of the originals.
For example, it renames FITS files in your folder starting with the tag MICADO
to simple, easily readable names like `MICADO_PSF1.fits`, `MICADO_PSF2.fits`, and so on.
</div>

**Download the script:** 
<a href={`${useBaseUrl('/downloads/TIPTOP_rename_psf_files.py')}`} download="TIPTOP_rename_psf_files.py"><span style={{ fontSize: '1.5em' }}>üì•</span></a>

<details>
  <summary><strong> Rename output PSF FITS files: `TIPTOP_rename_psf_files.py` </strong></summary>

  ```python
"""
Created on Thu Jul 10 14:15:45 2025
Rename output PSF FITS files sequentially for easier access and keep original copies.

@author: astro-tiptop-services
"""

#%% =============================================================================
# Import necessary libraries
import os
import shutil

#%% =============================================================================
# === Configuration ===
#üí° Adapt these paths to your environment
inputDir = "./"    # Directory containing the generated FITS files 
backupDir = "Original_PSFs"  # Directory to store backups of original files
outputDir = "Renamed_PSFs" # Directory where renamed files will be moved (must exist)

TagBase = "MICADO"     # Base name used in the output FITS filenames

# Create output and backup directories if they do not exist
os.makedirs(outputDir, exist_ok=True)
os.makedirs(backupDir, exist_ok=True)

#%% =============================================================================
# === Gather and sort relevant FITS files ===
output_files = sorted(
    [f for f in os.listdir(inputDir) if f.startswith(TagBase) and f.endswith(".fits")]
)

# Check if any matching files are found
if not output_files:
    print("[INFO] No matching FITS files found for renaming.")
else:
    print(f"[INFO] Found {len(output_files)} FITS files to rename.")

#%% =============================================================================
# === Copy and Rename files sequentially as TagBase_PSF1.fits, MICADO_PSF2.fits, etc. ===
for i, fname in enumerate(output_files):
    src = os.path.join(inputDir, fname)
    dst = os.path.join(outputDir, f"{TagBase}_PSF{i+1}.fits")
    backup = os.path.join(backupDir, fname)

    try:
        # Copy the original file to the backup folder
        shutil.copy2(src, backup)

        # Rename (and move) the file to the new destination
        os.rename(src, dst)
        print(f"[INFO] Renamed: {fname} ‚Üí {TagBase}_PSF{i+1}.fits (Backup saved)")
    except PermissionError:
        print(f"[‚ö†Ô∏è  WARNING] File in use and cannot be renamed: {fname}")
    except Exception as e:
        print(f"[‚ùå ERROR] Failed to rename {fname} ‚Üí {e}")

#%% =============================================================================
print(f"\n‚úÖ Process complete. {len(output_files)} files renamed and backed up.")

  ```
</details>


### üîµ Sum rotated PSF

<div style={{ textAlign: "justify" }}>
This script combines multiple PSFs into a single image by rotating each individual PSF 
by a specified field rotation angle before summation. <br/>
Used together with the two previous scripts, this process can be 
especially useful, for example, when simulating long integrations to reproduce the impact of pupil rotation and field rotation on the final image.


‚úèÔ∏è **Note**: You need to manually define the list of field rotation angles in the script ‚Äî one angle per PSF FITS file.<br/>
Feel free to adapt this script to suit TipTop simulations involving multiple science sources.
The example provided here illustrates its use with the input parameter file
[MICADO.ini](/docs/orion/aoinstruments#micado). <br/>
</div>
**Download the script:** 
<a href={`${useBaseUrl('/downloads/TIPTOP_rotated_PSF_sum.py')}`} download="TIPTOP_rotated_PSF_sum.py"><span style={{ fontSize: '1.5em' }}>üì•</span></a>

<details>
  <summary><strong> Sum rotated AO PSFs: `TIPTOP_rotated_PSF_sum.py` </strong></summary>

  ```python
"""
Created on Thu Jul 10 15:01:55 2025
Sum rotated PSFs.
Each PSF is rotated by a specified angle before summation.

@author: astro-tiptop-services
"""

#%% =============================================================================
# Import necessary libraries
import os
import numpy as np
from scipy.ndimage import rotate
from astropy.io import fits

#%% =============================================================================
# === Configuration ===
inputDir = "Renamed_PSFs"           # Folder where the PSF FITS files are stored
TagBase = "MICADO"                  # Base tag for the PSF files
outputFile = "PSF_sum.fits"         # Filename for the combined output

# Rotation angles (degrees) applied to each PSF before summation
rotation_angles = [...] # üí° To be defined
N = len(rotation_angles)  # Should match the number of PSF files available

#%% =============================================================================
# === Load and combine rotated PSFs ===
first_filename = os.path.join(inputDir, f"{TagBase}_PSF1.fits")
if not os.path.exists(first_filename):
    raise FileNotFoundError(f"Base file {first_filename} is missing. Check input directory.")

first_img = fits.getdata(first_filename)
accumulated = np.zeros_like(first_img, dtype=float)  # Accumulator for summing rotated PSFs
valid_count = 0  # Count how many files were found and used

# Loop over all images and angles
for i in range(N):
    filename = os.path.join(inputDir, f'{TagBase}_PSF{i+1}.fits')

    # Check if file exists
    if not os.path.exists(filename):
        print(f"[WARNING] Missing file: {filename}")
        continue

    print(f"[INFO] Loading file: {filename}")
    img = fits.getdata(filename)

    # Rotate the image by the corresponding angle
    rotated = rotate(img, angle=rotation_angles[i], reshape=False)

    # Accumulate the rotated image
    accumulated += rotated
    valid_count += 1

#%% =============================================================================
# === Normalize and save result ===
if valid_count > 0:
    accumulated /= valid_count

    # Save PSF sum to a FITS file, overwrite if exists
    fits.writeto(outputFile, accumulated, overwrite=True)
    print(f"[INFO] Combined PSF saved to: {outputFile}")
else:
    print("[ERROR] No valid PSF files found. No output generated.")

  ```
  </details>
